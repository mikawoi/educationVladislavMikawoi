Типы указателей
- обычный
- сингулярный (nullptr)
  - нельзя разыменовывать
  - можно проверять на равенство
- указатель, следующий за последним в массиве
  - нельзя разыменовывать
  - можно использовать в арифметике указателей и сравнениях

Диапазон (объектов)
- `[`first, last ) состоит из всех объектов (элементов) от * first до * (last - 1) включительно
- является допустимым
  - last достижим из first
  - можно получить адрес каждого объекта
  - пустой диапазон `[`p, p) является допустимым

Свойства диапазонов

- если непустой диапазон`[`first, last ) является допустимым, то `[`first + 1, last ) является допустимым
- если `[`first, mid ) и `[`mid, last ) допустимые, то `[`first, last ) допустимые
- если `[`first, last ) допустимые и элемент mid достижим из first, last достижим из Mid, то `[`first, mid ) и `[`mid, last ) допустимые

Массив, как диапазон
- ![[Pasted image 20240106191329.png]]

Регулярный тип (ведет себя как встроенный)

- конструированный по умолчанию
- копирование сохраняет равенство
- сравнение по значению
- равенство и неравенство согласованы 
- неравенство строгое и согласовано с равенством

![[Pasted image 20240106191454.png]]

## Контейнер

- содержит свои элементы
- является регулярным типом
- предоставляет доступ к элементам

Свойства элемента контейнера

- элемент принадлежит не более, чем одному контейнеру
  - контейнеры не пересекаются
  - ограничение на объекты, а не на значения
- время жизни элемента не превышает время жизни контейнера
  - создается не раньше
  - удаляется не позже

Иерархия концепций контейнеров

- контейнер произвольного доступа
- реверсивный контейнер
- однонаправленный контейнер
- контейнер как итератор ввода

Итератор

- интерфейс между алгоритмами и структурами данных
- регулярный тип (operator= (), operator== () )
- доступ к элементу контейнера по разыменовыванию указателя ![[Pasted image 20240106191949.png]]
- навигация по контейнеру

Принцип идентичности

- соотношения равенства итераторов и равенства объектов
	i1 == i2  <==> &* i1 == &* i2 
	i1 == i2  ==> * i1 == * i2 
	
Константные и изменяемые итераторы

- константный итератор
  - доступ к константному объему
  - константный объект (редко)
  *пример*
  ```cpp
  const int* pData = 0
  int* const pData = &pA;
```

Итератор произвольного доступа
- допускает написание алгоритма с произвольным доступом к контейнеру
- все манипуляции за константное время
- ![[Pasted image 20240106192658.png]]

Двунаправленный итератор

- допускает написание многопроходного алгоритма![[Pasted image 20240106193053.png]]

Однонаправленный итератор

- допускает написание однопроходного алгоритма - operator++ ()
- возможно существование более одного итератора для интервала

Итератор Вывода

- однопроходное чтение элементов
  - не изменяет сами элементы
  - единственный итератор для диапазона
  - по диапазону нельзя пройти более одного раза
operator++ ()

Итератор Ввода

- однопроходная запись элементов
  - не сравниваются
  - единственный итератор для диапазона
  - по диапазону нельзя пройти более одного раза
operator++ ()


Классы итераторов в STL
- iterator и const_iterator
- являются вложенными классами для классов контейнеров
*пример*
```cpp
vector<int>::iterator
list<int>::const_iterator
```

Вложенные типы 

- определяются внутри определения типа (класса, структуры)
- подчиняются спецификаторам доступа
- доступ с помощью оператора разрешения области видимости![[Pasted image 20240106194010.png]]

Интервал элементов контейнера
begin() - первый элемент
end() - элемент, следующий за последним
cbegin(), cend() - const версии

Унификация интерфейса (функции)
Унификация интерфейса функции означает создание единого стандарта для взаимодействия с функцией, независимо от того, какая часть программы её использует. Это позволяет упростить код, делает его более понятным и облегчает его дальнейшее использование и поддержку.
![[Pasted image 20240106194259.png]]

Список (структура данных) 
- последовательный доступ к элементам
- состоит из узлов
- узел содержит
  - собственно данные
  - связи с другими узлами

### Односвязный список
![[Pasted image 20240106194514.png]]

Двусвязный список
![[Pasted image 20240106194531.png]]


Навигация по линейному списку
![[Pasted image 20240106194803.png]]
![[Pasted image 20240106194811.png]]
![[Pasted image 20240106194819.png]]
![[Pasted image 20240106194830.png]]

Вставка узла
![[Pasted image 20240106194921.png]]
![[Pasted image 20240106195530.png]]
![[Pasted image 20240106195540.png]]

Удаление узла
![[Pasted image 20240106195556.png]]
![[Pasted image 20240106195604.png]]
![[Pasted image 20240106195617.png]]

Уничтожение списка - удаление узлов до полного исчезновения

Реализация :
```cpp
#include <iostream>

// Создаем структуру для узла списка
struct Node {
    int data;     // Значение узла
    Node* next;   // Указатель на следующий узел
};

class LinkedList {
private:
    Node* head; // Указатель на начало списка

public:
    // Конструктор
    LinkedList() {
        head = nullptr;
    }

    // Добавление элемента в конец списка
    void append(int value) {
        // Создаем новый узел
        Node* newNode = new Node;
        newNode->data = value;
        newNode->next = nullptr;

        if (head == nullptr) { // Если список пуст
            head = newNode;
        } else {
            // Находим последний узел
            Node* temp = head;
            while (temp->next != nullptr) {
                temp = temp->next;
            }
            // Добавляем новый узел в конец списка
            temp->next = newNode;
        }
    }

    // Метод для печати списка
    void printList() {
        Node* temp = head;
        while (temp != nullptr) {
            std::cout << temp->data << " ";
            temp = temp->next;
        }
        std::cout << std::endl;
    }
};

// Пример использования
int main() {
    LinkedList list;

    // Добавляем элементы в список
    list.append(1);
    list.append(2);
    list.append(3);
    list.append(4);

    // Выводим список
    list.printList();

    return 0;
```

Плюсы списков

- простое динамическое добавление и удаление элементов
- размер ограничен только объемом памяти и разрядностью указателей
- элементы не перемещаются в памяти

Минусы списков

- накладные расходы памяти на связи
- <<долгое>> обращение к элементу по индексу
- <<долгое>> выделение узла
- элементы списка могут быть расположены в памяти разреженно (фрагментация памяти)
Существует кольцевой список
![[Pasted image 20240106195955.png]]

## АТД "стек"

- упорядоченный набор элементов
- LIFO
- добавление и удаление элементов с одного конца

Операции стека

- создание/уничтожение
- добавление элемента
- удаление элемента
- проверка на пустоту (isEmpty() )
- получение значения верхнего элемента
![[Pasted image 20240106200144.png]]

![[Pasted image 20240106201731.png]]

### АТД "очередь"

- упорядоченный набор элементов
- FIFO 
  - удаление с головы
  - добавление в хвост

Операции очереди

- создание/уничтожение
- добавление элемента
- удаление элемента
- проверка на пустоту
- получение значение верхнего элемента
![[Pasted image 20240106202032.png]]
![[Pasted image 20240106202039.png]]

Операции над контейнерами и валидность итераторов

- операции над контейнерами могут делать итераторы невалидными (зависит от реализации итераторов/контейнеров)
- гарантии безопасности описаны в стандарте
- всегда следить за валидностью итераторов
- избегать хранения итераторов

Контейнеры переменного размера

- последовательность (sequence)
- ассоциативный контейнер (associative container)

Последовательности в STL
![[Pasted image 20240106202759.png]]
![[Pasted image 20240106202816.png]]
![[Pasted image 20240106202826.png]]
![[Pasted image 20240106202836.png]]

Реверсивные итераторы для контейнеров

- значения интервала в обратном порядке
- специальные свойства и методы
		reverse_iterator
		rbegin() и rend()
		crbegin() и crend()
- отличаются от обычных итераторов

reverse_iterator
- класс-адаптер для iterator
- для интервала `[`f, l) интервал `[`reverse_iterator(l), reverse_iterator(f)) содержит значения в обратном порядке
- основное тождество 
![[Pasted image 20240106203238.png]]

Доступ к элементам 
```cpp 
std::list
```
- через итератор (обобщенный вариант)
- с концов
- элементы произвольно расположены в памяти
- элементы не перемещаются
![[Pasted image 20240106203406.png]]
![[Pasted image 20240106203418.png]]

### АТД "дека"

- блочно-списочная структура
- произвольный доступ
- быстрая вставка/удаление в середине
- изменение числа элементов делает итераторы невалидными

Операции и их представители в C++:

1. удаление переднего элемента - pop_front();
2. удаление заднего элемента - pop_back();
3. добавление элемента вперёд - push_front();
4. добавление элемента назад- push_back();
5. получение переднего элемента - front();
6. получение заднего элемента - back();
7. проверка на пустоту - empty().

![[Pasted image 20240106203735.png]]
### АТД "множество"

- отсортированный, уникальные значения
- последовательно итерируется в порядке
- допускает параметризацию сравнения
- обычно реализуется сбалансированным деревом поиска

Операции и их представители в C++:

1. добавление элемента - insert();
2. удаление элемента - erase();
3. проверка наличия - find() (если == s.end(), то данного элемента нет);
4. пересечение множеств - std::set_intersection();
5. объединение множеств - std::merge();
6. проверка на пустоту - empty().

Для общего развития есть ещё <.multiset>

![[Pasted image 20240106204002.png]]
![[Pasted image 20240106204131.png]]
![[Pasted image 20240106204202.png]]

### АТД "очередь с приоритетом"

- <ключ, данные>
- порядок извлечения элементов определяется ключом, а не порядком добавления элементов в очередь

![[Pasted image 20240106204320.png]]

Адаптеры STL

- класс, преобразующий интерфейс адаптируемого типа к нужному интерфейсу
- в stl - шаблонный класс
![[Pasted image 20240106204649.png]]
![[Pasted image 20240106204657.png]]
![[Pasted image 20240106204709.png]]
![[Pasted image 20240106204718.png]]


Как искать быстро?

Двоичный поиск

- осуществляется только в отсортированном массиве
- сравнение искомого с "центральным"
- рекурсивный поиск в "подходящей" половине

Тонкости бинарного поиска

- пустой массив
- результат для отсутствующего значения
- переполнение в большом массиве
- на концах (первый/последний) в массиве
- повторяющиеся элементы

Двоичное дерево поиска

- все поддеревья - деревья поиска
- для произвольного узла Х значения ключей
  - в левом поддереве меньше
  - в правом поддереве не меньше
 ![[Pasted image 20240106205036.png]]
![[Pasted image 20240106205057.png]]

Хеширование

- детерминированный алгоритм преобразования данных в битовую строку фиксированной длины
- хеш - битовая строка заданной длины
- коллизия - одинаковый хеш для разных данных

Основный свойства хеш-функции

- длинна (разрядность)
- вычислительная сложность
- распределение значений
- криптостойкость

Характеристика хорошей хеш-функции
- быстро вычисляется
- минимизирует количество коллизий
- идеальное хеширование
  - отображает каждый ключ в хеш без коллизий
  - уникальный идентификатор ключа, без сохранения какой-либо информации о ключе

![[Pasted image 20240106205432.png]]

Хеш-таблица как структура данных

- хранение и поиск пар вида <ключ, значение>
- хорошо работает, если
  - хеш-ключи сравниваются быстрее объектов
  - коллизии редки
  - 
Поиск в хеш-таблице

- хеширование
- проверка наличия значений в таблице
- разрешимость коллизии
![[Pasted image 20240106205615.png]]
![[Pasted image 20240106205623.png]]
![[Pasted image 20240106205629.png]]

Последовательности проб

- линейная
- квадратичная
- двойное хеширование
Умолчательные параметры функции (необязательные)

- последние параметры в списке могут иметь умолчательные инициализаторы
- вычисляются на этапе компиляции
- не должны мешать разрешению перегрузки
Пример
```cpp
void f(int a, int b = 0, int c = 0);

f(z);
f(y, z);
```

Висячая ссылка

- невалидная ссылка
- может быть получена возвратом ссылки на объект, который разрушается раньше ссылки
  - локальный из функции
  - на динамический  и разрушаемый руками
- избегать такие ситуации
```cpp
int& GetValue() {
	int val = 0;
	return val;
}

auto v = GetValue();
v += 1;
```
Эта ссылка невалидная потому, что функция GetValue() возвращает ссылку на локальную переменную val, которая будет удалена из памяти после завершения функции. Поэтому повторное обращение к этой ссылке может привести к неопределенному поведению.

Глобальную переменную стоит делать static 

extern (ключевое слово)
- тип хранения
- объявление внешней функции или переменной
пример: 
// в a.cpp 
int gObjectsCounter(0);
// в b.cpp
extern int gObjectsCounter;

Использовать extern 
- только в случае необходимости
  - поддержка старого кода
  - стыковка со сторонними библиотеками
- чревато
	- тонкие ошибки проверки типов
	- неконтролируемый доступ к общим данным

static (ключевое слово)

- тип хранения 
- применим к переменным и функциям
- видимость - единица трансляции
- время жизни - время жизни программы

Статические переменные

- память выделяется в специальной области
- локальная переменная
	- "конструируется" при первом обращении
	- сохраняет значение между вызовами
*Пример*
```cpp
// в point.cpp
static int gModuleCallCount = 0;

int inside(const Pt& p, const Rect& rc) {
	static int nFuncCallsCount = 0;
	nFuncCallsCount += 1;
	gModuleCallsCount += 1; // плохо
}
```

Статический член типа

- является частью типа, но не экземпляра
- доступ
	- через экземпляр
	- через имя типа
- должен быть где-то определен (единственным образом)
![[Pasted image 20240108170246.png]]
![[Pasted image 20240108170347.png]]
Время жизни статических объектов

- порядок создания и уничтожения
	- до C++11 не был определен между разными единицами трансляции
	- может быть источником ошибок

Указатель на функцию

ReT (* T) ();
T pF (funcName);
ReT result (pF() );

![[Pasted image 20240108170650.png]]

Опасности

- слабый или отсутствующий контроль типов
- накладные на вызовы функций
- глобальные данные

Но это все нужно для

- реализации динамического поведения
	- функции обратного вызова (callback)
	- подгрузка исполняемого кода (динамические библиотеки)
- повторное использование кода
- архитектурная гибкость

Можно заменить на

- функторы
  - тип с перегруженным operator()
  - обычно, struct, так как должны не иметь состояния
  - лямбды

Функторы

- пользовательский тип
- перегружает операторы вызова функции operator()
- используется для параметризации алгоритмов
- может встраиваться компилятором в тело алгоритма

Пример
![[Pasted image 20240108173055.png]]
Стандартные функторы
- заголовок <.functional>
- ![[Pasted image 20240108173131.png]]
Обертка функции std::function

- заголовок <.functional>
- Полиморфное использование функции(означает возможность вызова одной и той же функции с разными типами данных или аргументами.)
	  - указатель на функцию
	  - лямбда
	  - привязка выражения
	  - функтор
- хранение, передача, вызов

Лямбда-выражение 

- определяет (локальный) анонимный тип
- экземпляр можно хранить
- экземпляр можно копировать (передавать)
- экземпляр используется для вызова функции

Определение лямбда-выражения

[], (), {}
[] - список захвата
() - список аргументов
-> тип возвращаемого значения (необязательно)
{} - блок кода (может быть пустым)

Тип возвращаемого значения для лямбды

- суффиксный стиль (->)
- если опущен
	  - для тела в виде return вычисляется по типу возвращаемого выражения
	  - если return несколько - должен быть один тип
	  - void, если опущено возвращаемое значение

Список захвата

- список и способ захвата локальных переменных (из области определения), которые могут использоваться внутри лямбда-выражения (помимо аргументов)
- умолчательно переменные захватываются как константные значения
![[Pasted image 20240108174240.png]]

Захват нескольких переменных

- индивидуальные спецификаторы (значения/ссылка)
- через запятую перечисляем
- каждая переменная один раз
пример
[width, height, &type]

Можно изменять захваченное, например

- снять спецификатор const с захваченных по значению локальных переменных
[] () mutable {}

```cpp
// Пример лямбда-выражения
int main() {
    int a = 5;
    int b = 10;
    // Захват переменной по значению и по ссылке
    auto func = [a, &b](int x) -> int {
        b = 100; // Изменение захваченной по ссылке переменной b
        return a * x; // Возвращаемое значение
    };

    int result = func(2); // Вызов лямбда-выражения
    return 0;
}

```

Висячие ссылки при захвате

- захваченные по ссылке переменные должны существовать дольше самой лямбды
- минимизировать захват по ссылке для хранимых лямбд
- избегать создания таких ситуаций
Захват с инициализацией

- новая локальная переменная
- тип и значение вычисляется один раз в процессе компиляции
![[Pasted image 20240108175550.png]]
Умолчательные значения параметров

- аналогично обычным функциям
![[Pasted image 20240108175621.png]]
Хранение лямбд

- помнить про уникальность типа
- использовать шаблон function<.T>
- следить за копированием или перемещением лямбд
Лямбда-выражение может храниться в переменной с помощью ключевого слова `auto` или указания типа `std::function`. Это позволяет передавать лямбда-выражение в качестве аргумента в другие функции. Вот примеры:

```cpp
#include <iostream>
#include <functional>

int main() {
    // Сохранение лямбда-выражения в переменной используя auto
    auto func = [](int x, int y) { return x + y; };

    // Передача лямбда-выражения в функцию
    int result = processNumbers(5, 3, func);
    std::cout << "Result: " << result << std::endl;

    // Сохранение лямбда-выражения в переменной типа std::function
    std::function<int(int, int)> func2 = [](int a, int b) { return a * b; };

    // Передача лямбда-выражения в другую функцию
    int result2 = calculate(4, 6, func2);
    std::cout << "Result 2: " << result2 << std::endl;

    return 0;
}

int processNumbers(int a, int b, std::function<int(int, int)> operation) {
    return operation(a, b);
}

int calculate(int x, int y, std::function<int(int, int)> operation) {
    return operation(x, y);
}
```

Таким образом, лямбда-выражение можно сохранить в переменной и передать в другие функции для выполнения конкретных операций.

Пример
```cpp
#include <iostream>
#include <vector>
#include <functional>

using namespace std;
int main()
{
    int x = 1;
    vector<function<int(int)>> fs; // Исправлено: указываем, что лямбда-выражения принимают int
    fs.push_back([](int x) { return 2 * x; });
    fs.emplace_back([](int) { return 1; });
    for (const auto &f : fs) {
        cout << f(6) << ' '; // Исправлено: передаем значение 6 в качестве аргумента для лямбда-выражений
    }
    return 0;
```

Generic Lambda

- ключевое слово auto в списке параметров
- автогенерация кода для вычисленного типа

![[Pasted image 20240108181328.png]]
![[Pasted image 20240108181408.png]]
![[Pasted image 20240108181418.png]]

Immerdiately Invoked Function Expression (IIFE)

- вызов лямбды сразу после создания
- может использоваться для инициализации сложных объектов
- плохо заметно в коде
*пример*
```cpp
int x = 1;
int y = 1;
[&] () { ++x; ++y; } ();
cout << x << " " << y << endl;
```

Рекомендации

- избегать умолчаний при захвате
- избегать висячих ссылок при захвате
- помнить, что лямбды могут копироваться

![[Pasted image 20240108182714.png]]
![[Pasted image 20240108182733.png]]
![[Pasted image 20240108182743.png]]
![[Pasted image 20240108182750.png]]

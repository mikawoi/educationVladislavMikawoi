Не надо использовать повторяющиеся значения без имен, использовать сразу числа

Что делать вместо этого
- Использовать динамические структуры данных
- Выносить параметры алгоритма в отдельные переменные
- использовать локализованные const и constexp(не может быть изменено и инициализируется сразу и может быть вычислено соответственно) переменные

Вывод типа из инициализатора (auto)
- тип определяется однозначно на этапе компиляции
- тип сложен в написании или не известен (шаблон)
```cpp
auto a = 18;
auto a = 18.5;
```

Какие типы можно вывести?
- может быть константой const auto
- может быть ссылкой auto&
- может быть константной ссылкой
- const auto&

Не злоупотреблять использованием auto
- польза должна превышать вред
- помнить, что
  1) не уверен - не используй
  2) тип есть всегда
  3) размер области видимости не играет роли


цикл по диапазону (range based for)

- итерирование элементов последовательности
*пример*
```cpp
for (range-decl : range-exp);
for (int v : arr) {
//...
}
```

Обработка текста:

Все начиналось с Си-строк ```<cstring>```

- массив символов char заканчивающийся нуль-терминатором
- источник постоянных ошибок
Проблемы си-строк
- низкоуровневая работа с массивом (указатели)
- не учитывается константность 
- отслеживание конца строки
- отслеживание размера буфера
- большое число функций
#### Символ

- char
- целочисленный тип (не менее 1 байт)
- хранит код символа ASCII
- ' ' - символьный литерал

Как вывести код символа?

Можно вывести значение типа int через ```static_cast<int>(ch)```

В строковом литерале значения символов зависят от кодировки файла исходного кода

Строковый класс (std::string)

- стандартная библиотека ```<string>```
- стандарт не определяет конкретный способ хранения строк в памяти
- стандарт допускает реализацию с подсчетом ссылок
- часто оптимизировано для коротких строк

Шаблонное объявление строки на С++ выглядит так:
```cpp
std::basic_string<char> str;
```

Создание строки

- пустая строка - string str;
- инициализация строковым литералом - string str("misis")
- копирование существующей - string str(strOld)

Инициализация строки символом
- невозможна инициализация символом - string('a') - ОШИБКА
- возможна инициализация несколькими экземплярами символа
              string(count, 'a')

Присваивать строки можно так:
- assign
- operator=
![[Pasted image 20240106124351.png]]

Размер строк аналогичен вектору
- размер буфера - capacity
- резервирование - reserve
- длина строки - length, size
- изменение длины - resize

Преобразование в c-строку:

- const Ch* c_str() const - записывает символы в массив, дополняя финальным нулем
- const Ch* data() const - без нуля
- копирование из внутреннего буфера во внешний - copy

Присоединение к строке
- append
- operator+=

Конкатенация строк
- объединение содержимого строк opearator+
- избегать массового использования
Пример
```cpp
strNew = strOld + "Oliver" + string(" Polumna");
```

Можно вставлять символы в строку:

- insert - вставка подстроки (где posName - счет идет с 1)
```cpp
strNew.insert(posName, name);
```
- replace - вставка с заменой
```cpp
str.replace(pos, lnOld, lnNew, name);
```

Поиск в строке:

- std::string::size_type
- std::string::npos - при неудачном поиске
- find - заданная группа символов
- rfind - с конца, заданная группа символов

Поиск совпадающих 

- find_first_of - первый символ из заданной группы
- find_last_of  - последний символ из заданной группы

Поиск отличающихся 

- find_first_not_of - первый символ из заданной группы
- find_last_not_of  - последний символ из заданной группы

Доступ к символам

- operator[] - по индексу без контроля
- at 
  - по индексу с контролем выхода за границы
  - при ошибке исключение std::out_of_range

Удаление символов
- erase - удаление символов
- clear - очистка строки
Проверка на пустоту происходит с помощью bool empty() const

Ввод и вывод через operator>> и operator<< соответственно 

Символы можно сравнивать
- через упорядочение в алфавите
- через упорядочивание с кодовой таблице
- символы нижнего регистра меньше символов верхнего

Сравнение строк
- происходит лексикографическим сравнением символов до первого несовпадения
- упорядоченность строк определятся порядком несовпадающих символов
Функции сравнения строк
```cpp
operator== - и все на сравнение
compare
```

Потоковый вывод и ввод

- вывод - преобразование объектов(типа) в последовательность символов
- ввод - запрос последовательности символов и преобразование ее в объект
Тип потока (базовый класс)

- ostream - вывода
- istream - ввода
- iostream - ввода и вывода

Заголовочные файлы
```cpp
<iostream>
<iomanip> - манипуляторы
<fstream>
<sstream>
<iosfwd> - опережающие объявления
<streambuf> - буферы
```

Преимущества стандартной библиотеки ввода/вывода

- контроль типов передаваемых данных
- использование одного кода для работы с разными потоками
- расширяемость
  - возможность ввода и вывода новых типов
  - новые классы потоков

Стандартные потоки

- глобальные переменные
- возможно перенаправление
- консольный ввод и вывод (cin и cout)
- протоколирование ошибок (cerr)
- ведение логов (clog)

Базовые операции

- открытие (создание)
- запись в поток
- чтение из потока
- проверка состояния
- закрытие (уничтожение)

Манипуляторы - специальные объекты, вызывающие функции потока. 
Стандартные манипуляторы определены в пространстве имен std

Буферизация потоков
- для записи и чтения используется буфер, который освобождается при переполнении или по требованию
через str.flush() - можно освободить

Синтаксис форматированного ввода и вывода

перегруженные операторы двоичного сдвига

```cpp
cout << "a=" << a;

operator<<(cout, "a=").operator<<(a);
```

Построчный ввод текста
(обычно используется для чтение текстового файла по строкам)
std::string str;
getline(std::cout, str);

Неформатированный ввод

-чтение отдельного символа или последовательности из потока

- get - символ
- read - последовательность

аналогично с выводом
- put - отдельный символ в вывод
- write - последовательность

Логирование - инструмент отладки

- добавление в код отписывающих сообщений
  - внутреннее состояние
  - принятые решения и переходы
- отключается в финальной версии

В больших проектах логирование используется

- использование специальных библиотек
  - удаленная отладка
  - с конфигурированием
  - с использованием уровней
  - с ротацией логов
  - умолчательно выключено или минимально 
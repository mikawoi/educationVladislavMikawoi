![[Pasted image 20240108202631.png]]
![[Pasted image 20240108202703.png]]
![[Pasted image 20240108202715.png]]

Использование библиотек

- включить заголовок
- использовать в исходном коде
  - объявления
  - определения
  - макросы
- скомпоновать библиотеку
  - ключи компоновщика или опции проекта в IDE

Как решать проблемы

- для каждого .h свой .cpp
![[Pasted image 20240108202850.png]]
![[Pasted image 20240108202902.png]]

.h может содержать

- директивы включения, маркоопределения и директивы  условной компиляции
- именованные пространства имен
- объявления имен типов, функций и данных
- определения типов
- определения встроенных типов, функций и шаблонов
- определения констант

.h не должен содержать

- определения обычных функций
- определения данных
- определения агрегатов (В C++ термин "агрегат" используется для описания типа данных, который может быть инициализирован списковой инициализацией и не имеет пользовательских конструкторов, виртуальных функций или виртуальных базовых классов)
- неименованные пространства имен

Реализация повторного использования кода

	-создание новых типов на основе существующих
- композиция (агрегация)
- наследование

Композиция (отношение)

- способ создания новых типов
- новый тип включает поля несуществующих типов
  - встроенные
  - пользовательские (классы и структуры)
![[Pasted image 20240108203629.png]]

Наследование (отношение)

- способ создания новых типов
- позволяет явно отражать общность типов (новый тип наследует члены)

Иерархия

- базовый (родительский) класс
- производный (дочерний) класс
- предок, потомок

- нужна для иерархии
  - данные
  - интерфейс (поведение, ответственность)

![[Pasted image 20240108203935.png]]
Синтаксис наследования следующий
```cpp
class Derived
	: [private|protected|public] Base {
	//class body
};
```

Умолчательный спецификатор типа наследования

- private для классов
- public для структур
- спецификатор рекомендуется указывать явно

*example*
```cpp
class Derived
	: public Base {
	...
};
```

Повышающее преобразование типа

- повышающее преобразование типа - приведение указателя (ссылки) производного типа к указателю (ссылке) базового типа
- при обращении через указатель или ссылку к экземпляру производного типа можно обращаться как с экземпляром базового типа

![[Pasted image 20240108204621.png]]

![[Pasted image 20240108204652.png]]

Подстановочный критерий

- в любой точке вызова базового типа может быть использован производный тип
или
- любой экземпляр производного типа является допустимым экземпляром родительского типа

Конструирование производных объектов

- конструктор базового класса должен быть вызван
- умолчательные конструкторы базовых типов могут быть вызваны неявно компилятором

*Список инициализации пример*
```cpp
Student::Student (const string& name, const string& secname, const Group& group)
	: Man(name, secname)
	, group_ (group) {
	...
};
```
Конструктор производного класса

- должен 
	- инициализировать базовый тип
	- инициализировать собственные поля
- непосредственная инициализация полей базового типа невозможна
Порядок вызова конструкторов

- по всей цепочке иерархии наследования, начиная от корневого базового типа и до текущего
- на каждом уровне вызывается
	  - конструктор базового типа
	  - конструкторы полей

Деструктор

- каждый класс содержит единственный деструктор (без аргументов)
- компилятор гарантирует вызов всех деструкторов (по всей иерархии наследования)

Порядок вызова деструкторов

- обратный порядку вызова конструкторов
- по всей цепочке иерархии наследования, начиная от текущего и до корневого базового типа
- на каждом уровне вызывается
  - деструкторы полей
  - деструктор базового типа

Замещение метода

- в производном типе может быть определен метод с именем метода базового класса
- переопределение перегруженного имени функции базового типа скрывает все остальные версии в производном типе

Изменение интерфейса

Сигнатура в C++ обычно означает список параметров функции вместе с их типами и порядком, но без имени функции. Сигнатура используется для однозначной идентификации функции и отличия её от других функций в контексте перегрузки функций.

изменение интерфейса базового типа посредством модификации сигнатуры и/или типа возвращаемого значения означает, что тип используется не тем способом, для которого обычно предназначается наследование

Доступ к скрытым именам осуществляется через полное имя

*example*
```cpp
void Derived::print(ostream& ostr) {
	Base::print(ostr);
}
```

Ненаследуемые функции
- конструкторы
- деструкторы
- operator=
![[Pasted image 20240108210323.png]]
![[Pasted image 20240108210333.png]]

Статические функции (при наследовании)

- наследуются производными типа
- переопределение скрывает все остальные перегруженные версии в базовом типе
- то-есть аналогично обычным функциям

Выбор между композицией и наследованием

- композиция
	- отношение "has-a" (b содержит а)
	- повторное использование кода
- наследование
	- отношение "is-a" (b является а)
	- повторное использование интерфейса

Закрытое наследование

- лучше использовать композицию
- реализует "ограниченную реализацию"
- пользователь не имеет доступа к базовой функциональности
- экземпляр производного типа не может интерпретироваться как экземпляр базового
![[Pasted image 20240108211456.png]]
Защищенность

- ключевое слово protected
- защищенный член ведет себя как
	- открытый для членов производных типов
	- закрытый для всех остальных функций
Защищенное наследование 

- реализует
	- открытую реализацию для производных и дружественных типов 
	- "ограниченную реализацию" для других типов
	на практике используется редко
![[Pasted image 20240108211905.png]]
Рекомендации

- делайте все данные private, обеспечивая доступ к ним через методы
- используйте protected для методов реализации, которые могут использоваться в производных классах

Виды наследования

- одиночное наследование - один непосредственный базовый класс
- множественное наследование - более одного непосредственного базового класса
![[Pasted image 20240108212056.png]]

Проблемы множественного наследования

- неоднозначность имен (членов и методов)
- повторяющиеся базовые классы (ромбовидные схемы наследования)
- размещение данных в памяти
- порядок и количество вызовов методов

Использование множественного наследования

- избегать
- использовать для наследования нескольких интерфейсов

Связывание

- соотнесение вызова функции с телом функции
- раннее связывание
	  - реализуется компилятором и компоновщика до запуска программы (при "сборке")
- позднее (динамическое) связывание
	  - в процессе исполнения

Виртуальная функция
- объявляется виртуальной в базовом классе с помощью ключевого слова virtual
- связывается динамически при косвенном использовании объекта базового класса
- остается виртуальной во всех производных классах (достаточно объявить в базовом классе)

Переопределение виртуальной функции
- повторное определение виртуальной функции в производном классе
- использование override в производных классах для контроля перекрытия
- использование модификатора final для запрета дальнейшего переопределения

Использование virtual

- избегать использования virtual в определениях функций
- избегать использования virtual в объявлениях производных классов
![[Pasted image 20240108213237.png]]
![[Pasted image 20240108213256.png]]

Расширяемость

- универсальный код
	- взаимодействует только с интерфейсом типа (т.е. базового класса)
- возможно добавление новых производных классов, без изменения универсального кода

Поиск тела виртуальной функции

- компилятор гарантирует наличие тела для виртуальной функции
- если виртуальная функция не переопределяется в классе, то вызывается ближайшее определение по иерархии
![[Pasted image 20240108213641.png]]
![[Pasted image 20240108213733.png]]
![[Pasted image 20240108213903.png]]
![[Pasted image 20240108213926.png]]
![[Pasted image 20240108213938.png]]
![[Pasted image 20240108214000.png]]
![[Pasted image 20240108214038.png]]

Эффективность использования виртуальных функций

- минусы
	  - дополнительные инструкции для каждого вызова виртуальной функции
	  - дополнительный код для инициализации
	  - дополнительная память для хранения
- плюсы
	- повышение гибкости программ
	- повышение эффективности работы программистов

Чисто виртуальная функция

- объявление начинается с virtual и заканчивается "= 0"
- должна реализовываться в производном классе

*пример*
```cpp
virtual int func() = 0;
```

![[Pasted image 20240108214702.png]]

Абстрактный класс

- содержит нереализованные чисто виртуальные функции
- создание экземпляров АК запрещено
- при наследовании от абстрактного класса все чисто виртуальные функции должны быть реализованы

АК как тип

- определяет тип (интерфейс)
- используется в качестве базового в иерархии наследования
- используется в реализации алгоритмов над объектами типа

Использование абстрактных классов
- запрещает передачу экземпляров по значению
- гарантирует осуществление повышающего приведения типа через указатель или ссылку

Определение чисто виртуальной функции

- аналогично обычной
- класс остается абстрактным
- позволяет вызывать общий код в производных типах
![[Pasted image 20240108215200.png]]
![[Pasted image 20240108215250.png]]
![[Pasted image 20240108215302.png]]
![[Pasted image 20240108215324.png]]

Чисто виртуальный деструктор

- имеет право на жизнь
- должен иметь тело
- предотвращает возможность создания экземпляров класса

Однокоренные иерархии

- работа с контейнерами
- отладочный функционал
	- протоколирование
	- сохранение/восстановление данных
 ![[Pasted image 20240108215510.png]]
 ![[Pasted image 20240108215528.png]]
 ![[Pasted image 20240108215543.png]]
 ![[Pasted image 20240108215556.png]]
 
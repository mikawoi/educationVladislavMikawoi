### void
пустой тип, служащий для того, чтобы указать, что функция ничего не возвращает
void* - указатель на объект неизвестного типа 

*Функции

1) Изолированный фрагмент кода
2) Нужны, чтобы решать некоторую задачу
3) Предназначены для повторного использования
   - оформлена по правилам языка
   - может принимать параметры (вход)
   - может возвращать некоторое значение(выход)
Объявление функции

Важно указать тип возвращаемого значения T или void
Указать имя функции, список параметров (может быть пустым, пары тип-значение через запятую)

Определение функции
- объявление + тело
- типы аргументов объявления и определения должны совпадать
- Рекомендуется поддерживать соответствие имен аргументов
Аргумент (параметр)

- семантика локальной переменной
- инициализируется в точке вызова
- область видимости = тело функции
Передать аргументы можно по ссылке и по значению

### Ссылка

- тип T& - тип <<ссылка на T>>
- Альтернативное имя переменной
- Инициализируется при определении
Код (аргумент ссылка)
```cpp
void swap(int& lhs, int& rhs) {
int newLhs = rhs;
rhs = lhs;
lhs = newLhs; }
```

### Возвращаемое значение
- задается выражением в инструкции return
- обязано быть, если это не void функция
- void функция не имеет return
- неименованная временная переменная
- должно быть сохранено в точке вызова, если это значение нужно далее

### Вызов функции

Вызов
- обращение по имени
- перечисление аргументов
Аргумент
- фактически передаваемое значение параметра
- определен в точке вызова
- передается в зависимости от типа параметра

В С++ имеются математические константы, использовать их можно 2 способами, либо делая так до C++20
```cpp
#define _USE_MATH_DEFINES
#include <cmath
```

либо подключая библиотеку numbers
std::numbers::pi 
начиная с C++20

## Объектный подход (ОО)
- программа = модель
- все описывается в терминах "объектов"
- объекты могут быть в отношениях
- Объекты "живут" и "взаимодействуют"
  1) обладают состоянием и поведением

Терминология ООП:
- Структура - пользовательский тип
- Класс - пользовательский тип с существующим инвариантом - представляет собой утверждение о состоянии объекта, которое должно быть выполнено в каждый момент времени. Относится к концепции сохранения условий, которые должны быть выполнены постоянно
- Экземпляр - объект типа, переменная
- Поле - данные, переменная типа/экземпляра
- Метод - функция типа/экземпляра
- Член - поле или метод

### Доступ к членам
- для экземпляров через оператор доступа к члену точку .
  - пример center.x = newPos;
- для классов через оператор :: разрешения имени
  - Console::ReadLine()

### Метод
- Определен для экземпляра
- вызывается через экземпляр Obj.method()
- реализация может обращаться к обычным и статическим членам (это такие переменные или методы, которые принадлежат классу в целом, а не конкретному экземпляру)
### Константность 
- замена препроцессора
- строгий контроль типов
- защита данных
- оптимизация

Защита данных:
- инициализация в процессе выполнения
- не предусмотрено изменение
- Компилятор пресекает попытки потенциального изменения
Константные переменные не изменяются после определения
Константные параметры не изменяются внутри функции

#### Перегрузка функций
- использование одного имени для операции с разным набором аргументов
- одна из форм полиморфизма  - это способность объектов разных классов отвечать на один и тот же вызов метода с различным поведением.

Форма записи выражений
Традиционная - a + b, префиксная + a b

Операторная функция - имя начинается с ключевого слова operator, после которого идет сам оператор
Операторы можно и нужно перегружать

Приоритет операторов
- определен в стандарте языка
- не может быть изменен
##### Унарные оператор
- выражение @aa или aa@
- нестатический метод без аргументов aa.operator@()
- свободная функция с одним аргументом operator@(aa)
Префиксная и постфиксная формы унарных операторов
префиксные - возвращает результат вычисления
постфиксные - возвращает  исходное значение аргумента

Префиксные и постфиксные операторы также называют сигнатурами
Префиксный оператор:
- T& operator++()
Постфиксный:
- T operator--(int)

### Бинарный оператор (aa @ bb)

Метод с одним аргументом
aa.operator@(bb)
Свободная функция с двумя аргументами
operator@(aa, bb)

***Ограничение перегрузки операторов
- нельзя создать "новый" оператор
- нельзя изменить число аргументов
- нельзя изменить приоритет

### Раздельная компиляция 
- Компилятор
  - Компиляция независимых компонент
  - Генерация объектного кода
- Компоновщик (linker)
  - связывание объектного кода
  - генерация исполняемого кода
- преодоление ограничений компилятора
- повторное использование
Компоновщик (linker) берет объектные файлы, сгенерированные компилятором, и связывает их вместе, чтобы создать исполняемый файл. Это включает в себя захват необходимых библиотек, разрешение ссылок между компонентами и генерацию исполняемого кода. Раздельная компиляция также помогает преодолеть ограничения компилятора, такие как ограничения по объему исходного кода, и позволяет повторное использование объектного кода для улучшения производительности и облегчения разработки программного обеспечения

### Этапы сборки программы
- препроцессор
- компилятор -> сообщения об ошибках
- компоновщик-> сообщения об ошибках
- возможна оптимизация на этапах компиляции и компоновки
- в IDE происходит "автоматически"

### Единица компиляции
Исходный файл + препроцессор - > единица компиляции
Компилируется в собственный объектный файл
Определяет границы видимости

### Препроцессор
- Директивы включения *#include
- Директивы условной компиляции *#if, #else, #endif
- Операции со строками
  - - # - преобразование аргумента в строку
  - - ## - конкатенация строк
#### Маркоопределения
- подстановка текстовых значений #define, #undef
- могут определяться на уровне ключей компилятора или опций среды разработки
  Примеры
**#define NOMINMAX
**#define min(a,b) ((a) <= (b) ? (a) : (b))

Использование препроцессора
надо МИНИМИЗИРОВАТЬ
- Заголовки - подключение, стражи включения (это метод, который предотвращает повторное включение одного и того же заголовочного файла в процессе компиляции в языках программирования C и C++. Обычно они используются с помощью директив препроцессора, таких как #ifndef, #define и #endif.)
- Языкозависимые фрагменты кода
- платформозависимые фрагменты кода

### Использование библиотек
- Включить заголовок
- Использовать в исходном коде
  - объявления
  - определения
  - макросы
- Скомпоновать библиотеку
  - Ключе компоновщика или опции проекта в IDE

**Модульность** - это принцип разработки программного обеспечения, который подразумевает разделение сложной системы на независимые, маленькие и легко обслуживаемые модули. Каждый модуль выполняет определенную функцию или задачу, и их можно комбинировать для создания более крупных систем.

#### Реализация модульности в C++
- функция - единица логики исполнения
- модуль(.cpp) - единица организации исходного кода
- общие объявления выносят в заголовок
Включение заголовочных файлов может происходит по-разному
1) Стандартное через <>
2) Пользовательское через " "

Порядок поиска файлов:
- определяется реализацией компилятора
- может быть причиной ошибок
- переменные окружения
- опции компилятора
- текущая папка

Как решать проблемы?
- в идеале для каждого .h свой .cpp
- анализировать логику работы include
- анализировать сообщения и смотреть код
- на уровне ключей компиляции или IDE можно включить вывод порядка включения


## Массив
- объект обладающий множеством свойств:
- хранилище однотипных элементов
- быстрый поиск элементов по индексу
- объекты одного типа, расположенные в памяти подряд

Абстрактный тип данный (АТД) массив:
- создание и уничтожение
- копирование
- доступ к элементам по индексу
- получение размера
- сравнение
АТД динамический массив:
- удаление элемента
- вставка элемента(-ов)
- изменение количества элементов

Существует встроенный массив - избегать использование
- составной пользовательский тип T`[size]` - 'массив из size элементов типа T'
- элементы индексируются от 0 до size - 1

Массивы в STL(Standart Template Library)
- заголовки `<array> and <vector>`
- массив фиксированного размера - array
- динамический массив vector

Массив фиксированного размера 
```cpp
std::array<T, N>
```
- замена встроенным массивам
- произвольный доступ
- объявление
```cpp
template <class T, size_t N> struct array;
```
Динамический массив
- замена new[]/delete[]
- изменяемый размер
- быстрая вставка/удаление в конец
- медленная вставка в середине и начале

Внутренняя организация vector:
- автоматическое управление памяти с помощью буферизации
- политика изменяемости размера буфера
  - -выделение по необходимости
  - *`*`2 при добавлении элемента
  - сохранение размера при удалении элемента

Массивы тоже переменные, поэтому их можно инициализировать, можно это делать списком 
![[Pasted image 20240105220504.png]]

Доступ к элементам
- по индексу
  - -с контролем - at()
  - -без контроля - operator[]()
- с концов
- через итератор
можно делать проверку на пустоту empty(), число элементов size(), максимальное число элементов системно max_size(), доступ к первому front()

в векторе еще
- capacity() - максимальное число элементов в буфере
- void reserve(size_t) - гарантировать размер буфера (элементов)
- void shrink_to_fit() - поджать размер буфера

Можно изменить число элементов std::vector 
1) void resize(size_t count)
2) void resize(size_t count, const T& val)
- лишнее отбрасывается
- новое заполняется (по умолчанию)

Можно изменять vector

- push_back(const T& val)
- pop_back()
- void clear() - зачистка с сохранением буфера

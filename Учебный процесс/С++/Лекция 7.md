
## Структура

- составной пользовательский тип
- определяет набор произвольных типов
- именованный доступ

*пример*
```cpp
struct Vec2i {
	int x;
	int y;
};

Vec2i v1;
Vec2i v2 = { 3, 5 };
```

Умолчательный инициализатор поле

- указывается в определении типа с помощью = или { }

```cpp
struct Vec2i {
	int x = 0;
	int y = 0;
};
```

Доступ к членам структур

- . - оператор доступа к члену
- -> оператор разыменования члена структуры (для указателя на экземпляр структуры)
```cpp
pt.x = 1;
pt->x = pt->y;
```

![[Pasted image 20240107134313.png]]


Структуры - POD (Plain Old Data)

- копирование экземпляров "по памяти" является допустимым
```cpp
auto pt_next = pt_prev;
pt_curr = pt_next;
```

Строгое перечисление (enum class)

- пользовательский тип
  - строгая проверка типов компилятором
  - отсутствие неявных преобразований
- набор именованных константный значений
- возможно уточнение типа хранения
```cpp
enum class KeyWord {
	kAsmM,
	kAuto,
	kBreak
};

KeyWord w = KeyWord::rAsm;

void f(const KeyWord& currWord);
```
```cpp
enum class Status : std::uint32_t {
	kUndefined = -1,
	kOff = 0,
	kOn = 1,
	kDisable = 255
};
```

Перечисление (enum)
не использовать

- приводится к целому в выражениях
- имена экспортируются в окружающую область видимости
- может не иметь имени

Инициализация

```cpp
= // C
( ) // C++98
{ } // C++11 universal
```
*пример*
```cpp
int a = 15;
```
Стиль инициализаторов

{ } для агрегаторов и по "необходимости"
= для одиночных значений
![[Pasted image 20240107140132.png]]

Неявные преобразования

- повышение
  - bool -> int
  - enum -> int or long
- обеспечение точности
  - int + long -> long
  - int + double -> double
- округление
  - int n(f);
  - int k{f}; // ошибка компиляции

Явные преобразования

1)  static_cast<тип>(выражение)
	преобразование родственных типов при компиляции
	
*пример*
```cpp
int roundV(static_cast<.int>(double_v));
```
Однако следует быть осторожным при использовании static_cast, так как оно не выполняет дополнительных проверок на безопасность преобразования как dynamic_cast или reinterpret_cast.

2) const_cast<тип>(выражение)
	снятие const и volatile
```cpp
char* p_beg(const_cast<.char*>(p + n));
```
Оператор const_cast используется для удаления или добавления квалификатора const (или volatile) из типа переменной. Это позволяет изменять константность переменной без нарушения принципов безопасности типов. Пример использования const_cast:

```cpp
const int a = 5;
int* b = const_cast<int*>(&a); // убираем const
*b = 10; // теперь можно менять значение a
```

Однако следует использовать const_cast осторожно, поскольку изменение константности переменной может привести к непредсказуемым результатам и нарушению инвариантов программы. В большинстве случаев изменение const-квалификатора является признаком неправильного проектирования программы.
3) reinterpret_cast<тип>(выражение)
	интерпретация объекта
```cpp
char* p(reinterpret_cast<.char*>(adr));
```
Оператор reinterpret_cast используется в C++ для преобразования типов указателей или ссылок одного типа в другой без выполнения проверок или конвертации. Это позволяет обойти стандартные правила преобразования типов и может привести к неопределенному поведению, если не используется осторожно. Применение reinterpret_cast может быть опасным, так как оно игнорирует типы и может привести к ошибкам во время выполнения, если используется неправильно. Чаще всего его применяют в особых случаях, когда необходимо выполнить приведение типов, и нет другого способа это сделать.

#### memsize типы
- пригодны для хранения
  - указателей
  - индексов массивов
заголовки
```cpp
<cstddef> and <cstdint>
for 1
ptrdiff_t
size_t
for 2
intptr_t
uintptr_t

```

#### Адрес

- Целое неотрицательное число
- унарный оператор & - получение адреса
- nullptr - невалидный адрес 
  - ВАЖНО! не использовать макрос NULL и литерал 0 

Невалидный указатель
- гарантируется отсутствие объектов с адресом nullptr
- разыменование nullptr ошибка времени исполнения 
- всегда проверять адрес перед использованием

#### Указатель

- тип T* - тип <<указатель на T>>
- переменная T* содержит адрес объекта типа T
- унарный оператор * - разыменование
*пример*
```cpp
char c1 = 'a';
char* p = &c1;
char c2 = *p;
```

Встроенный массив можно инициализировать так

- списком инициализаторов
- размер встроенного массива может быть вычислен по списку инициализации
- не указанные в списке значения инициализируются по умолчанию
- использовать надо Т arr[SIZE] {0};
*пример*
```cpp
int ar1[] {1, 2, 3, 4}; 
int ar2[32] {1, 2}; 
int ar3[MAX_NUMS] {0}; 
```

Указатели и массивы 

- имя массива - указатель на первый элемент
- доступ через указатели или оператор []

*пример*
```cpp
p = &v[0];
v[i] == *(p + i);
```

Доступ к элементам массива можно получить по 

- указателю на массив и индекс - data[i]
- указателю на элемент массива - * (pData + i)

Сложение/вычитание указателя с целым числом

- "сдвиг" указателя(адреса) на заданное число элементов массива
- результат разыменования не определен, если адрес вне массива

Вычитание указателей

- определено только для указателей на элементы одного массива
- число элементов массива между указателями

Указатель на void

- содержит адрес объекта
- допустимые операции
  -  присвоение адреса
  - сравнение на равенство и неравенство
  - явное преобразование к указателю на другой тип
- запрещенные операции
  - разыменование
  - арифметические операции

Указатель на константу и константный указатель

- указатель на константную переменную
	const T* p = nullptr
- константный указатель
	T* const pC = &obj;
- константный указатель на константную переменную
	const T* const pC = &obj;

Что же лучше использовать, объект, указатель или ссылку?

- если тип не фундаментальный, использовать ссылку или указатель
- предпочтительно ссылки
- если объект может не существовать, использовать указатель
- важно помнить о константности 


## Память (статическая, стек, куча)

- статическая память (при компиляции)
  - глобальные переменные
  - статические переменные
- стек
  - параметры функций
  - локальные переменные
- куча (heap)
  - динамическое распределение new/delete

Статические и глобальные объекты

- создаются до начала работы main
- уничтожаются сразу после
- порядок для разных единиц трансляции не определен
- при нужде стоит использовать принцип Construct On First Use Idiom

Стековые объекты

- область видимости = время жизни
- создаются в точке определения
  - локальные переменные
  - переменные циклов
  - передаваемые параметры функций
- уничтожаются при выходе из блока

Что касаемо кучи (динамические объекты)

- время жизни определено самим пользователем, не ограничено областью видимости
- живут в динамической памяти (кучи)

Создание динамического объекта происходит через ==new T==
- оператор выделения памяти
- возвращает адрес объекта
*пример*
```cpp
int* pCounter = new int(0);
Complex* pZ = new Complex;
```

Ошибки выделения памяти

- запуск исключения std::bad_alloc
- noexcept версия new вернет nullptr

Уничтожение динамического объекта

delete
- оператор освобождения памяти
- указатель продолжает хранить адрес

Динамические массивы - **использовать по необходимости**

new T[SIZE] - оператор выделения памяти
delete[] - оператор освобождения памяти

пример
![[Pasted image 20240106154311.png]]

Типовые проблемы

- чтение мусора
  - чтение из чужой памяти (возможно неинициализированной)
- порча памяти
  - запись в чужую память
связанные с new и delete

- утечка памяти
  - исользования выделения без удаления
- порча - вызов delete для уже освобожденной памяти или произвольного адреса

Практика использования new и delete - использовать при нужде

- освобождать выделенную память
- инициализировать и зачищать указатели
- инкапсулировать в типы ctor/dtor
- использовать умные указатели и контейнеры

### Пространство имен (namespace)

- Логически группирует объявления
- определяет область видимости
- может быть вложенным
- может быть анонимным
- открыто
  - можно добавить имена в пространство

Создание пространств
```cpp
namespace <<имя_пространства>> {
//
}

namespace misis {
	int getGroupsCount();
}
```

Доступ к именам в пространстве происходит через оператор разрешения области видимости ::
имя_пространства::имя

Глобальное пространство имен

- все, что не лежит в собственном пространстве имен
- доступно через ::

using - директива
вносит все имена из пространства имен в текущую область видимости
```cpp
using namespace std;
```

можно использовать отдельное имя
```cpp
using std::cin;
```

Using - псевдоним

using псевдоним_типа = тип
```cpp
using Vec = std::vector<int>;
Vec v;
```

Сокрытие имен
```cpp
int x(10); // глобальная переменная

void f() {
int x(0); // скрывает глобальную
x = 1; // присваивание локальной
::x = 5; // присваивание глобальной
}
```
